# 工作流模板开发手册

本文档详细说明如何为 ROD CLI 创建自定义的工作流模板，包含完整的开发指导和技术规范。

## 🎯 设计原则

创建新工作流模板应该遵循"工作流程优先"的设计原则：
1. **先定义工作流程** - 明确你的开发方法论和阶段划分
2. **再设计目录结构** - 基于工作流程确定需要的文件和命令
3. **最后实现功能** - 编写 AI 命令、脚本和模板文件
4. **持续优化完善** - 根据实际使用反馈迭代改进

## 📋 创建步骤

### 第一步：定义工作流程

创建 `workflow.md` 文件，详细描述你的工作流程：

```markdown
# [你的工作流名称] 工作流

## 工作流概述
- 目标技术栈：如 Vue3 + TypeScript、React Native、Spring Boot 等
- 适用场景：如企业级应用、移动端开发、微服务架构等
- 核心特色：如安全性要求、性能优化、特定业务流程等

## 工作流阶段定义

### 阶段 1: [阶段名称] (`/command1`)
- **目标**: 该阶段要达成的具体目标
- **输入**: 需要什么输入信息或前置条件
- **处理**: 具体执行什么操作和逻辑
- **输出**: 生成什么文件或状态变更
- **下一步**: 指导用户进行下一步操作

### 阶段 2: [阶段名称] (`/command2`)
[重复上述结构...]

## 特色功能和工具集成
- 专用工具集成：如 Figma MCP、特定测试框架等
- 质量保障：代码规范、测试策略、安全检查等
- 自动化支持：脚本工具、模板生成、状态同步等

## 与默认工作流的差异
明确说明与 ROD 默认工作流的不同之处和增强功能
```

### 第二步：基于工作流程设计目录结构

根据你在 `workflow.md` 中定义的阶段，设计模板目录结构：

```
your-workflow-template/
├── README.md                 # 模板说明（包含 workflow.md 的引用）
├── workflow.md              # 工作流程详细定义
├── commands/                # AI 助手命令（必需）
│   ├── command1.md          # 对应工作流阶段 1
│   ├── command2.md          # 对应工作流阶段 2
│   ├── command3.md          # 对应工作流阶段 3
│   └── ...                  # 其他阶段命令
├── spec-templates/         # 辅助commands生成指定的spec文档（推荐）
│   ├── spec-template.md     # 定制化的规范模板
│   ├── plan-template.md     # 定制化的设计模板
│   ├── tasks-template.md    # 定制化的任务模板
│   └── roadmap-template.md  # 项目路线图模板
├── scripts/                 # 自动化脚本（可选）
│   ├── common.js           # 通用工具函数
│   ├── analyze-modules.js   # 定制化的分析脚本
│   └── ...                 # 其他专用脚本
├── memory/                 # 项目宪法（可选）
│   └── constitution.md     # 工作流特定的开发约束
└── rules/                  # 规则文件（可选）
    └── workflow-rules.md   # 工作流特定规则
```

### 第三步：编写 AI 命令文件

#### commands/ 目录的职责定位

`commands/` 目录包含的是 **AI 助手的指导性指令文件**。每个 `.md` 文件是一个完整的 AI 执行指令，告诉 AI 助手如何完成工作流中特定阶段的任务。这些指令文件是工作流自动化的核心，将抽象的工作流程转化为具体的 AI 执行步骤。

#### 指令文件与工作流的映射关系

每个命令文件应该对应 `workflow.md` 中定义的一个工作流阶段：
- 如果工作流定义了 5 个阶段，则创建 5 个对应的命令文件
- 文件名应简洁明了，反映阶段的核心功能（如 `specify.md`、`plan.md`、`tasks.md`）
- 每个命令的功能描述必须与 workflow.md 中的阶段目标保持一致

#### 指令文件的标准结构

为每个工作流阶段编写对应的 AI 命令文件，遵循以下格式：

```markdown
---
description: 命令的功能描述，对应 workflow.md 中的阶段说明
scripts:
  node: node .rod/scripts/your-script.js --json {ARGS}
---

[从 workflow.md 中复制该阶段的详细描述]

**执行步骤：**
1. **前置条件检查**
   - 检查必需的文件和环境
   - 验证上一阶段的输出

2. **加载模板**（如适用）
   - 加载 `.rod/spec-templates/xxx-template.md`
   - 基于工作流特点调整模板内容

3. **执行核心逻辑**
   - 实现 workflow.md 中定义的处理逻辑
   - 调用相关工具和集成

4. **生成输出**
   - 创建或更新相关文档
   - 输出到正确的 specs/ 目录结构

5. **下一步指导**
   - 指导用户执行后续命令
   - 提供质量检查建议

**重要说明：**
- 确保与 workflow.md 中的阶段定义保持一致
- 遵循 ROD 规范，输出到 specs/modules/ 目录结构
- 使用绝对路径进行所有文件操作
```

#### 参考示例

可以参考默认工作流中的指令文件（位于 `workflow/commands/`）来理解标准格式：
- `specify.md` - 指导 AI 如何分析业务需求，创建功能规范文档
- `plan.md` - 指导 AI 如何进行技术设计，生成架构方案
- `tasks.md` - 指导 AI 如何分解任务，制定开发计划

这些文件展示了如何将工作流阶段转化为具体的 AI 执行指令。

### 第四步：创建文档模板

#### spec-templates/ 目录的职责定位

`spec-templates/` 目录包含的是 **供 AI 指令使用的文档生成模板**。这些模板被 `commands/` 中的 AI 指令调用，用于模板化生成项目规范文档。模板包含占位符（如 `[功能名称]`、`[技术栈]`），AI 会根据用户输入替换这些占位符生成具体的项目文档。

#### 模板文件与commands的协作关系

每个模板文件通常对应一个或多个commands指令的输出需求：
- AI 指令在执行步骤中会加载相应的模板文件
- 基于模板结构和占位符生成具体的规范文档
- 将生成的文档输出到正确的 `specs/modules/` 目录结构中

#### 模板设计原则和参考示例

基于工作流的特殊需求，定制化文档模板。可以参考默认工作流提供的四个核心模板作为示例：

**spec-template.md 定制要点：**
- 包含工作流特定的需求格式
- 添加技术栈相关的验收标准模板
- 集成特定业务领域的规范要求
- 使用 `[功能名称]`、`[业务场景]`、`[验收标准]` 等占位符

**plan-template.md 定制要点：**
- 预定义技术栈的架构选择
- 包含工作流特有的设计模式
- 集成专用工具和框架的使用指导
- 使用 `[技术栈]`、`[架构图]`、`[接口规范]` 等占位符

**tasks-template.md 定制要点：**
- 反映工作流的开发实践（如 TDD、安全检查等）
- 包含技术栈特定的任务类型
- 集成质量保障和测试策略
- 使用 `[任务列表]`、`[优先级]`、`[工期估算]` 等占位符

**roadmap-template.md 定制要点：**
- 生成项目整体进度规划
- 包含里程碑、模块依赖、时间线等
- 使用 `[项目名称]`、`[里程碑]`、`[交付节点]` 等占位符

#### 灵活定制原则

- **不强制要求特定数量或类型的模板**：根据工作流阶段需要来设计相应的模板
- **可以继承默认模板**：复用 `workflow/spec-templates/` 中的标准模板
- **也可以完全重新设计**：基于工作流特色创建全新的模板结构
- **占位符标准格式**：统一使用 `[描述性名称]` 标记需要替换的内容

### 第五步：实现支持脚本

如果工作流需要特殊的自动化支持，创建 Node.js 脚本：

```javascript
#!/usr/bin/env node
/**
 * [脚本功能描述] - 支持 workflow.md 中定义的 [具体阶段]
 */

const fs = require('fs');
const path = require('path');
const { getRepoRoot, getFeaturePaths } = require('./common');

// 实现工作流特定的逻辑
// 注意：只使用 Node.js 内置模块，不依赖第三方包

async function main() {
  // 脚本实现逻辑
}

if (require.main === module) {
  main().catch(console.error);
}

module.exports = { main };
```

### 第六步：编写项目宪法

创建 `memory/constitution.md`，定义工作流特定的开发约束：

```markdown
# [工作流名称] 项目宪法

## 核心原则
基于 workflow.md 定义的开发理念和原则

## 技术约束
- [技术栈] 特定的技术规范和限制
- 依赖管理策略
- 性能和安全要求

## 工作流约束
- 阶段执行顺序要求
- 质量门禁标准
- 文档完整性要求

## 质量保障
- 测试覆盖率要求
- 代码审查标准
- 部署前检查清单
```

## 🔧 模板测试和验证

### 本地测试步骤

1. **创建测试项目**
   ```bash
   # 将你的模板放在 packages/internal-templates/your-template/
   cd packages/internal-templates/
   mkdir your-template
   # 按照上述结构创建文件
   ```

2. **生成测试项目**
   ```bash
   cd ../../
   npm run build
   npm run dev -- init test-your-template --template your-template --ai claude
   ```

3. **验证生成结果**
   ```bash
   cd test-your-template
   # 检查 .rod/ 目录结构
   # 验证 AI 命令是否正确生成
   # 测试 workflow.md 是否被正确复制
   ```

### 质量检查清单

- [ ] `workflow.md` 定义清晰，阶段划分合理
- [ ] 目录结构符合 ROD 规范要求
- [ ] 所有 AI 命令文件包含完整的 Front Matter
- [ ] 命令实现与 workflow.md 中的阶段定义一致
- [ ] 生成的项目包含正确的 `.rod/` 目录结构
- [ ] 文档模板体现工作流的特色和要求
- [ ] 脚本使用 Node.js 内置模块，无外部依赖
- [ ] 本地测试生成正确的项目结构

## 📚 参考示例

查看现有的内部模板作为参考：

- **PUI 模板** (`packages/internal-templates/pui/`)
  - 技术栈：Vue3 + TDesign + 微信支付组件库
  - 工作流：5 阶段 + Figma 集成 + 组件库优先级
  - 特色：支付安全、组件映射、设计还原

## 🎯 进阶定制

### 工作流继承

新工作流可以继承默认工作流的基础能力：
- 复用 `module`、`specify`、`plan`、`tasks`、`progress` 基础流程
- 在此基础上添加或替换特定阶段
- 扩展模板内容和脚本功能

### MCP 工具集成

如果工作流需要集成特定的 MCP 工具：
- 在 `workflow.md` 中说明 MCP 工具的作用
- 在 AI 命令中添加 MCP 调用指导
- 在模板根目录提供 `.mcp.json` 配置文件

### 企业级扩展

在企业环境中，可以进一步定制：
- 集成企业内部工具和系统
- 添加合规检查和安全扫描
- 定制化部署和监控流程
- 集成企业级的项目管理工具

## 📐 技术规范

### 文件命名规范

#### 1. 命令文件命名
- 所有命令文件使用 `.md` 扩展名
- 文件名应简洁明了，反映命令的主要功能
- 使用小写字母和连字符分隔，如 `module.md`, `specify.md`

#### 2. 脚本文件命名
- 使用连字符分隔的小写命名：`create-module.js`
- 脚本名称应清楚表达其功能
- 统一使用 `.js` 扩展名

### 命令文件结构标准

每个命令文件必须包含以下部分：

#### Front Matter（必需）
```yaml
---
description: 命令的简短描述，说明其主要功能
scripts:
  node: node .rod/scripts/script-name.js --json {ARGS}
---
```

#### 命令说明（必需）
- 简要介绍命令的用途和价值
- 使用清晰的中文描述

#### 用法示例（推荐）
```markdown
**用法示例：**
- `/command arg1` - 单个参数示例
- `/command arg1 arg2` - 多个参数示例
```

#### 执行步骤（必需）
```markdown
**执行步骤：**
1. 步骤一的详细描述
2. 步骤二的详细描述
3. 输出结果和下一步指导
```

#### 下一步指导（推荐）
```markdown
**下一步：**
指导用户执行后续命令或操作
```

### 脚本技术要求

#### 1. 脚本组织
- `scripts/` - 包含所有 Node.js 脚本文件
- `scripts/common.js` - 通用工具函数和实用工具

#### 2. 脚本引用规范
- 脚本路径使用相对路径 `.rod/scripts/`
- 使用 Node.js (`node`) 统一脚本执行环境
- 参数传递使用 `{ARGS}` 占位符
- 依赖 Node.js 内置模块，无需额外依赖

#### 3. 脚本内容要求
- 使用 Node.js 内置模块实现，无需额外依赖
- 包含必要的错误处理和参数验证
- 支持 `--json` 参数用于结构化输出
- 包含简要的脚本用途说明注释
- 脚本头部使用 `#!/usr/bin/env node` 声明

#### 4. 技术约束
- **仅使用 Node.js 内置模块**：`fs`, `path`, `child_process`, `process`
- **严格禁止外部依赖**：不允许使用任何第三方 npm 包，确保脚本的轻量性和独立性
- **跨平台兼容**：确保在 Windows、macOS、Linux 上正常运行
- **轻量设计**：无需安装额外 npm 包依赖
- **错误处理**：合理的异常捕获和用户友好的错误信息

**重要约束**：
- ❌ 禁止添加任何 `require()` 第三方模块
- ❌ 禁止使用 `import` 外部包
- ✅ 只允许使用 Node.js 核心模块（如 `require('fs')`、`require('path')` 等）
- ✅ 允许引用同目录下的 `common.js` 工具函数

#### 5. 通用脚本文件
- `common.js` - 包含共享的实用函数，如 `getRepoRoot()`, `getFeaturePaths()` 等
- 其他脚本通过 `require('./common')` 引用共享函数

### commands 与 spec-templates 协作机制

#### 协作流程

1. **AI 指令加载模板**：
   - `commands/` 中的 AI 指令在执行步骤中会加载对应的 `spec-templates/` 模板
   - 通过路径 `.rod/spec-templates/xxx-template.md` 访问模板文件

2. **模板处理和定制**：
   - AI 根据工作流特点调整模板内容
   - 替换模板中的占位符（如 `[功能名称]`、`[技术栈]` 等）
   - 基于用户输入生成具体的规范文档

3. **文档输出**：
   - 将生成的文档输出到正确的 `specs/modules/` 目录结构
   - 遵循 ROD 规范的文档组织方式

#### 配合原则

- **一对一或一对多关系**：一个 command 可以使用一个或多个 template
- **命名对应关系**：通常 `specify.md` 使用 `spec-template.md`，`plan.md` 使用 `plan-template.md`
- **灵活扩展**：可以根据工作流需要创建专用的模板文件
- **继承机制**：新工作流可以复用默认模板，也可以完全重新设计

#### 实际应用示例

```markdown
**commands/specify.md 中的典型步骤：**
2. **加载模板**
   - 加载 `.rod/spec-templates/spec-template.md`
   - 基于工作流特点调整模板内容

3. **执行核心逻辑**
   - 分析用户业务需求
   - 填充模板占位符

4. **生成输出**
   - 在当前模块目录中生成 `spec.md`
   - 基于模板结构输出完整的功能规范文档
```

这种协作机制确保了工作流的一致性和可维护性，同时保持了足够的灵活性来适应不同的项目需求。

### 文档模板说明

#### spec-templates/ 目录结构
默认工作流提供四个核心文档模板，位于 `workflow/spec-templates/` 目录：

#### 1. `spec-template.md` - 功能规范模板
- **用途**: 定义功能的业务需求和验收标准
- **结构**: 使用 EARS 格式（易于评审、可实现、明确、相关、可测试）
- **占位符**: `[功能名称]`、`[业务场景]`、`[验收标准]` 等
- **适用**: 需求分析阶段，产品功能定义

#### 2. `plan-template.md` - 技术设计模板
- **用途**: 生成技术实现方案和架构设计
- **结构**: 包含技术选型、架构设计、接口定义、数据模型等
- **占位符**: `[技术栈]`、`[架构图]`、`[接口规范]` 等
- **适用**: 技术设计阶段，架构规划

#### 3. `tasks-template.md` - 任务规划模板
- **用途**: 将设计方案分解为具体的开发任务
- **结构**: 包含开发任务、测试任务、部署任务等清单
- **占位符**: `[任务列表]`、`[优先级]`、`[工期估算]` 等
- **适用**: 开发阶段，任务管理

#### 4. `roadmap-template.md` - 项目路线图模板
- **用途**: 生成项目整体进度规划
- **结构**: 包含里程碑、模块依赖、时间线等
- **占位符**: `[项目名称]`、`[里程碑]`、`[交付节点]` 等
- **适用**: 项目管理，整体规划

#### 模板设计特征
- **占位符格式**: 使用 `[描述性名称]` 标记需要替换的内容
- **结构化内容**: 提供完整的章节框架和格式示例
- **指导性说明**: 包含填写提示和最佳实践建议
- **技术无关**: 适用于各种技术栈和项目类型

### 项目宪法规范

#### constitution.md 结构
```markdown
# 项目宪法 (Project Constitution)

## 核心原则
- 规范驱动开发
- 测试驱动开发
- 模块化架构
- 增量开发
- 简洁性原则

## 质量门禁
- 设计阶段检查点
- 实现阶段检查点
- 集成阶段检查点

## 开发流程约束
- 五步工作流程
- 文档要求
- 代码提交规范

## 技术约束
- 依赖管理
- 性能要求
- 安全考虑

## 项目特定约束
根据项目特点定制的约束条件

## 治理规则
- 宪法优先级
- 修正流程
- 质量保证
```

## ✅ 质量标准

### 命令文件质量要求
- [ ] 包含完整的 Front Matter
- [ ] 命令描述清晰准确
- [ ] 执行步骤详细具体
- [ ] 输出结果和下一步指导明确
- [ ] 遵循 ROD 规范，输出到 specs/ 目录

### 脚本文件质量要求
- [ ] 仅使用 Node.js 内置模块
- [ ] 包含错误处理和参数验证
- [ ] 支持 --json 参数输出
- [ ] 跨平台兼容性
- [ ] 代码注释清晰

### 模板文件质量要求
- [ ] 占位符格式统一
- [ ] 结构化内容完整
- [ ] 包含指导性说明
- [ ] 技术栈无关设计
- [ ] 易于理解和使用

### 文档质量要求
- [ ] README.md 包含模板概述和使用说明
- [ ] workflow.md（如有）定义清晰的工作流程
- [ ] 文档间链接正确
- [ ] 格式统一规范
- [ ] 内容准确无误

### 模板结构标准

#### 必需目录结构
```
workflow-template/
├── commands/              # AI 助手命令（必需）
├── scripts/              # Node.js 自动化脚本（推荐）
├── memory/               # 项目宪法（推荐）
├── spec-templates/       # 用于给commands生成spec的模板（推荐）
└── README.md            # 模板说明（必需）
```

---

**重要提醒：**
创建新工作流模板时，始终以 `workflow.md` 为核心，确保所有其他文件都服务于工作流程的实现。遵循本文档的技术规范，可以确保创建的工作流模板具有良好的一致性、可维护性和用户体验。
